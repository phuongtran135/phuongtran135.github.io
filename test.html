<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Trình Tạo Ảnh Minh Họa Truyện Anime</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons for UI elements -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- JSZip is a required dependency for docx-preview and zipping files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Docx-preview library to handle .docx files -->
    <script src="https://cdn.jsdelivr.net/npm/docx-preview@0.1.15/dist/docx-preview.js"></script>

    <style>
      /* Custom styles for a better look and feel */
      body {
        font-family: "Inter", sans-serif;
        background: #111827; /* Dark background */
      }

      /* Custom scrollbar for a modern look */
      ::-webkit-scrollbar {
        width: 8px;
      }
      ::-webkit-scrollbar-track {
        background: #1f2937;
      }
      ::-webkit-scrollbar-thumb {
        background: #4f46e5;
        border-radius: 10px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #6366f1;
      }

      /* Custom spinner animation */
      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.2);
        border-left-color: #4f46e5;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Glassmorphism effect for containers */
      .glass-card {
        background: rgba(31, 41, 55, 0.6); /* bg-gray-800 with opacity */
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      /* Custom file input button styling */
      .file-input-label {
        cursor: pointer;
        transition: all 0.2s ease-in-out;
      }
      .file-input-label:hover {
        background-color: #4338ca; /* Darker indigo on hover */
      }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
  </head>
  <body class="text-gray-200">
    <div class="container mx-auto p-4 md:p-8">
      <!-- Header Section -->
      <header class="text-center mb-8">
        <h1
          class="text-4xl md:text-5xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-indigo-400 to-purple-500 mb-2"
        >
          Trình Tạo Ảnh Minh Họa Truyện
        </h1>
        <p class="text-lg text-gray-400">
          Biến câu chuyện của bạn thành những bức ảnh anime sống động.
        </p>
      </header>

      <!-- Main Content Area -->
      <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
        <!-- Left Panel: Input Controls -->
        <div class="lg:col-span-1 space-y-6">
          <div class="glass-card p-6 rounded-2xl">
            <h2 class="text-2xl font-semibold mb-4 flex items-center">
              <i
                data-lucide="book-marked"
                class="w-6 h-6 mr-2 text-indigo-400"
              ></i>
              Nội dung truyện
            </h2>

            <!-- Text Area for direct input -->
            <textarea
              id="story-text"
              class="w-full h-48 bg-gray-900 border border-gray-700 rounded-lg p-3 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-200"
              placeholder="Dán nội dung truyện của bạn vào đây..."
            ></textarea>

            <div class="mt-4 flex items-center">
              <input
                type="checkbox"
                id="manual-split-checkbox"
                class="h-4 w-4 text-indigo-600 bg-gray-700 border-gray-600 rounded focus:ring-indigo-500"
              />
              <label
                for="manual-split-checkbox"
                class="ml-2 block text-sm text-gray-300"
                >Tự chia cảnh thủ công (dùng '---' để phân tách)</label
              >
            </div>

            <div class="text-center my-4 text-gray-500">hoặc</div>

            <!-- File Upload Button -->
            <label
              for="docx-file"
              class="file-input-label w-full flex items-center justify-center gap-2 bg-indigo-600 text-white font-semibold py-3 px-4 rounded-lg"
            >
              <i data-lucide="upload-cloud" class="w-5 h-5"></i>
              Tải lên tệp .docx
            </label>
            <input type="file" id="docx-file" class="hidden" accept=".docx" />
            <p
              id="file-name"
              class="text-center text-sm text-gray-400 mt-2"
            ></p>
          </div>

          <div class="glass-card p-6 rounded-2xl">
            <h2 class="text-2xl font-semibold mb-4 flex items-center">
              <i
                data-lucide="user-circle-2"
                class="w-6 h-6 mr-2 text-indigo-400"
              ></i>
              Bảng Dữ liệu Liên tục
            </h2>
            <p class="text-sm text-gray-400 mb-3">
              Hệ thống sẽ tự động tạo bảng dữ liệu chi tiết. Bạn có thể chỉnh
              sửa lại nếu muốn.
            </p>
            <textarea
              id="character-description"
              class="w-full h-32 bg-gray-900 border border-gray-700 rounded-lg p-3 focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 transition duration-200"
              placeholder="Để trống để hệ thống tự phân tích hoặc tự nhập mô tả chi tiết vào đây..."
            ></textarea>
          </div>

          <!-- Action Buttons -->
          <div class="space-y-4">
            <button
              id="generate-btn"
              class="w-full bg-gradient-to-r from-indigo-500 to-purple-600 hover:from-indigo-600 hover:to-purple-700 text-white font-bold py-4 px-4 rounded-xl text-lg shadow-lg transform hover:scale-105 transition-transform duration-200 flex items-center justify-center gap-2"
            >
              <i data-lucide="wand-2" class="w-6 h-6"></i>
              Tạo ảnh minh họa
            </button>
            <button
              id="download-all-btn"
              class="hidden w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-xl text-lg shadow-lg transform hover:scale-105 transition-transform duration-200 flex items-center justify-center gap-2"
            >
              <i data-lucide="package-check" class="w-6 h-6"></i>
              Tải xuống toàn bộ (.zip)
            </button>
          </div>
        </div>

        <!-- Right Panel: Results -->
        <div class="lg:col-span-2">
          <div
            id="status-container"
            class="hidden text-center p-8 glass-card rounded-2xl flex-col items-center justify-center"
          >
            <div class="spinner mb-4"></div>
            <p id="status-text" class="text-lg font-medium">Đang xử lý...</p>
          </div>

          <div id="results-container" class="space-y-8">
            <!-- Generated images will be appended here -->
            <div
              id="placeholder"
              class="text-center p-12 glass-card rounded-2xl flex flex-col items-center justify-center h-full"
            >
              <i data-lucide="image" class="w-24 h-24 text-gray-600 mb-4"></i>
              <h3 class="text-xl font-semibold text-gray-400">
                Hình ảnh minh họa sẽ xuất hiện ở đây
              </h3>
              <p class="text-gray-500">
                Hãy nhập truyện của bạn và bắt đầu sáng tạo!
              </p>
            </div>
          </div>
        </div>
      </main>
    </div>

    <!-- Hidden div for docx-preview to render into -->
    <div id="docx-container" class="hidden"></div>

    <!-- Image Preview Modal -->
    <div
      id="image-modal"
      class="hidden fixed inset-0 bg-black bg-opacity-80 z-50 flex items-center justify-center p-4 transition-opacity duration-300"
    >
      <div class="relative">
        <img
          id="modal-image"
          src=""
          alt="Image Preview"
          class="max-w-[90vw] max-h-[90vh] rounded-lg shadow-2xl"
        />
        <button
          id="modal-close-btn"
          class="absolute -top-5 -right-5 bg-white text-black rounded-full p-2 hover:bg-gray-200 transition-transform hover:scale-110"
        >
          <i data-lucide="x" class="w-6 h-6"></i>
        </button>
      </div>
    </div>

    <script>
      // DOM Element References
      const storyTextArea = document.getElementById("story-text");
      const docxFileInput = document.getElementById("docx-file");
      const fileNameDisplay = document.getElementById("file-name");
      const manualSplitCheckbox = document.getElementById(
        "manual-split-checkbox"
      );
      const characterDescriptionInput = document.getElementById(
        "character-description"
      );
      const generateBtn = document.getElementById("generate-btn");
      const downloadAllBtn = document.getElementById("download-all-btn");
      const statusContainer = document.getElementById("status-container");
      const statusText = document.getElementById("status-text");
      const resultsContainer = document.getElementById("results-container");
      const placeholder = document.getElementById("placeholder");
      const docxContainer = document.getElementById("docx-container");
      const imageModal = document.getElementById("image-modal");
      const modalImage = document.getElementById("modal-image");
      const modalCloseBtn = document.getElementById("modal-close-btn");

      // State for image history
      let imageHistory = {};

      // Initialize Lucide Icons
      lucide.createIcons();

      // Event Listeners
      docxFileInput.addEventListener("change", handleFileSelect);
      generateBtn.addEventListener("click", handleGeneration);
      downloadAllBtn.addEventListener("click", handleDownloadAll);
      resultsContainer.addEventListener("click", handleCardActions);
      modalCloseBtn.addEventListener("click", closeModal);
      imageModal.addEventListener("click", (e) => {
        if (e.target === imageModal) {
          closeModal();
        }
      });

      function handleFileSelect(event) {
        const file = event.target.files[0];
        if (file) {
          fileNameDisplay.textContent = file.name;
          storyTextArea.value = ""; // Clear textarea if a file is chosen

          docx
            .renderAsync(file, docxContainer)
            .then((x) => {
              storyTextArea.value = docxContainer.innerText;
            })
            .catch((err) => {
              console.error("Error reading docx file:", err);
              displayError(
                "Không thể đọc tệp .docx. Vui lòng thử lại hoặc dán nội dung trực tiếp."
              );
            });
        }
      }

      async function handleGeneration() {
        const storyText = storyTextArea.value.trim();
        let characterDescription = characterDescriptionInput.value.trim();

        if (!storyText) {
          displayError("Vui lòng nhập nội dung truyện hoặc tải lên một tệp.");
          return;
        }

        imageHistory = {}; // Reset history for new generation
        downloadAllBtn.classList.add("hidden"); // Hide download all button

        if (!characterDescription) {
          setLoadingState(
            true,
            "Đang phân tích truyện để tạo Bảng Dữ liệu Liên tục..."
          );
          try {
            characterDescription = await generateAutomatedDescription(
              storyText
            );
            characterDescriptionInput.value = characterDescription;
          } catch (error) {
            console.error("Error generating character description:", error);
            displayError(
              error.message || "Không thể tự động tạo mô tả. Vui lòng tự nhập."
            );
            setLoadingState(false);
            return;
          }
        }

        setLoadingState(
          true,
          "Đang chuẩn bị và chia truyện thành các phân cảnh..."
        );
        resultsContainer.innerHTML = "";
        placeholder.classList.add("hidden");

        let processedStoryText = storyText;

        if (!manualSplitCheckbox.checked) {
          statusText.textContent = "AI đang phân tích và chia cảnh...";
          try {
            processedStoryText = await splitStoryWithAI(storyText);
          } catch (error) {
            console.error("Error with AI scene splitting:", error);
            displayError(
              error.message || "Không thể tự động chia cảnh bằng AI."
            );
            setLoadingState(false);
            return;
          }
        }

        const manualSeparator = "---";
        const originalTexts = processedStoryText
          .split(manualSeparator)
          .map((p) => p.trim())
          .filter((p) => p.length > 10);

        if (originalTexts.length === 0) {
          displayError(
            "Không tìm thấy phân cảnh nào. Hãy chắc chắn bạn đã đặt nội dung giữa các dấu phân cách '---' hoặc vô hiệu hóa chế độ thủ công."
          );
          setLoadingState(false);
          return;
        }

        for (let i = 0; i < originalTexts.length; i++) {
          const originalText = originalTexts[i];
          const sceneId = `scene-${i}`;

          statusText.textContent = `Đang xử lý phân cảnh ${i + 1}/${
            originalTexts.length
          }...`;

          let sceneText;
          try {
            sceneText = await createSceneDescription(originalText);
          } catch (error) {
            console.error(
              `Error creating scene description for scene ${i + 1}:`,
              error
            );
            createSceneCard(
              sceneId,
              "Lỗi tạo mô tả",
              originalText,
              false,
              null,
              error.message
            );
            continue;
          }

          statusText.textContent = `Đang tạo ảnh cho phân cảnh ${i + 1}/${
            originalTexts.length
          }...`;

          createSceneCard(sceneId, sceneText, originalText, true, null);

          try {
            const imageUrl = await generateImageForScene(
              sceneText,
              characterDescription
            );
            imageHistory[sceneId] = [imageUrl];
            updateSceneCard(sceneId, sceneText, originalText, false, imageUrl);
          } catch (error) {
            console.error(`Error generating image for scene ${i + 1}:`, error);
            updateSceneCard(
              sceneId,
              sceneText,
              originalText,
              false,
              null,
              error.message || "Lỗi tạo ảnh không xác định"
            );
          }
        }

        setLoadingState(false);
        if (Object.keys(imageHistory).length > 0) {
          downloadAllBtn.classList.remove("hidden");
        }
      }

      async function handleCardActions(event) {
        const regenerateButton = event.target.closest(".regenerate-btn");
        const restoreButton = event.target.closest(".restore-btn");
        const downloadButton = event.target.closest(".download-btn");
        const imageContainer = event.target.closest(
          ".image-container-for-modal"
        );

        if (regenerateButton) {
          await handleRegenerate(regenerateButton);
        } else if (restoreButton) {
          handleRestore(restoreButton);
        } else if (downloadButton) {
          handleDownloadSingle(downloadButton);
        } else if (imageContainer) {
          const img = imageContainer.querySelector("img");
          if (img && img.src) {
            openModal(img.src);
          }
        }
      }

      function handleDownloadSingle(button) {
        const card = button.closest(".glass-card");
        const img = card.querySelector("img");
        const sceneId = card.id;
        const sceneIndex = parseInt(sceneId.split("-")[1]) + 1;

        if (img && img.src) {
          const a = document.createElement("a");
          a.href = img.src;
          a.download = `phancanh_${sceneIndex}.png`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }
      }

      async function handleDownloadAll() {
        const zip = new JSZip();
        let imageCount = 0;

        for (const sceneId in imageHistory) {
          const history = imageHistory[sceneId];
          if (history && history.length > 0) {
            const latestImageSrc = history[history.length - 1];
            const sceneIndex = parseInt(sceneId.split("-")[1]) + 1;
            const fileName = `phancanh_${sceneIndex}.png`;

            const base64Data = latestImageSrc.split(",")[1];
            zip.file(fileName, base64Data, { base64: true });
            imageCount++;
          }
        }

        if (imageCount > 0) {
          downloadAllBtn.textContent = "Đang nén tệp...";
          downloadAllBtn.disabled = true;

          zip
            .generateAsync({ type: "blob" })
            .then(function (content) {
              const a = document.createElement("a");
              a.href = URL.createObjectURL(content);
              a.download = "toan_bo_truyen.zip";
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            })
            .finally(() => {
              downloadAllBtn.innerHTML = `<i data-lucide="package-check" class="w-6 h-6"></i> Tải xuống toàn bộ (.zip)`;
              lucide.createIcons();
              downloadAllBtn.disabled = false;
            });
        } else {
          alert("Không có ảnh nào để tải xuống.");
        }
      }

      async function handleRegenerate(button) {
        button.disabled = true;

        const card = button.closest(".glass-card");
        const sceneId = card.id;
        const sceneTextElement = card.querySelector(".scene-text-p");
        const originalTextElement = card.querySelector(".original-text-p");

        if (sceneTextElement && originalTextElement) {
          const sceneText = sceneTextElement.textContent
            .replace(/"/g, "")
            .trim();
          const originalText = originalTextElement.textContent
            .replace(/"/g, "")
            .trim();
          const characterDescription = characterDescriptionInput.value.trim();

          if (!characterDescription) {
            displayError("Không tìm thấy mô tả nhân vật để thử lại.");
            button.disabled = false;
            return;
          }

          updateSceneCard(sceneId, sceneText, originalText, true, null);

          try {
            const newImageUrl = await generateImageForScene(
              sceneText,
              characterDescription
            );
            if (imageHistory[sceneId]) {
              imageHistory[sceneId].push(newImageUrl);
            } else {
              imageHistory[sceneId] = [newImageUrl];
            }
            updateSceneCard(
              sceneId,
              sceneText,
              originalText,
              false,
              newImageUrl
            );
          } catch (error) {
            console.error(`Regeneration failed for scene ${sceneId}:`, error);
            const currentImageUrl = imageHistory[sceneId]
              ? imageHistory[sceneId][imageHistory[sceneId].length - 1]
              : null;
            updateSceneCard(
              sceneId,
              sceneText,
              originalText,
              false,
              currentImageUrl,
              error.message || "Lỗi tạo ảnh không xác định"
            );
          }
        } else {
          console.error("Could not find scene text to regenerate for", sceneId);
        }
      }

      function handleRestore(button) {
        const card = button.closest(".glass-card");
        const sceneId = card.id;
        const sceneTextElement = card.querySelector(".scene-text-p");
        const originalTextElement = card.querySelector(".original-text-p");

        if (
          sceneTextElement &&
          originalTextElement &&
          imageHistory[sceneId] &&
          imageHistory[sceneId].length > 1
        ) {
          const sceneText = sceneTextElement.textContent
            .replace(/"/g, "")
            .trim();
          const originalText = originalTextElement.textContent
            .replace(/"/g, "")
            .trim();

          imageHistory[sceneId].pop(); // Remove the current image
          const previousImageUrl =
            imageHistory[sceneId][imageHistory[sceneId].length - 1];
          updateSceneCard(
            sceneId,
            sceneText,
            originalText,
            false,
            previousImageUrl
          );
        }
      }

      async function splitStoryWithAI(userStory) {
        const systemPrompt = `Bạn là một đạo diễn truyện tranh chuyên nghiệp, tư duy theo từng khung hình (panel). Nhiệm vụ của bạn là đọc kỹ kịch bản và chia nó thành các khung hình riêng lẻ một cách chi tiết nhất có thể. Hãy giữ nguyên toàn bộ văn bản gốc. Tại mỗi điểm bạn xác định là bắt đầu một khung hình mới, hãy chèn một dòng CHỈ chứa ba dấu gạch ngang (---).

QUY TẮC QUAN TRỌNG: Hãy chia nhỏ các đoạn văn. Một đoạn văn có thể chứa nhiều hành động hoặc phản ứng khác nhau, và mỗi hành động/phản ứng đó nên là một khung hình riêng. Ví dụ:

Đoạn văn gốc: "Khi xe đang chạy trên đường, đột nhiên có một chú chó lao ra. Sếp vội phanh lại. Tôi ôm lấy ngực, thở phào, 'May quá'. Trong xe im lặng như tờ. Tôi vội vàng giải thích, 'Tôi không có ý nói sếp là chó...'. Sếp co giật khoé miệng, 'Im miệng ngay'."

Kết quả bạn nên trả về:
Khi xe đang chạy trên đường, đột nhiên có một chú chó lao ra. Sếp vội phanh lại.
---
Tôi ôm lấy ngực, thở phào, 'May quá'. Trong xe im lặng như tờ.
---
Tôi vội vàng giải thích, 'Tôi không có ý nói sếp là chó...'. Sếp co giật khoé miệng, 'Im miệng ngay'.

Hãy áp dụng tư duy chi tiết này cho toàn bộ câu chuyện. Không thêm bất kỳ văn bản nào khác, chỉ chèn dấu '---'.`;

        const chunks = splitTextIntoChunks(userStory);
        const processedChunks = [];

        for (let i = 0; i < chunks.length; i++) {
          statusText.textContent = `AI đang phân tích phần ${i + 1}/${
            chunks.length
          }...`;
          const chunk = chunks[i];
          const result = await processChunk(chunk, systemPrompt);
          processedChunks.push(result);
        }

        return processedChunks.join("");
      }

      function splitTextIntoChunks(text, maxLength = 4000) {
        const chunks = [];
        let remainingText = text;

        if (text.length <= maxLength) {
          return [text];
        }

        while (remainingText.length > 0) {
          if (remainingText.length <= maxLength) {
            chunks.push(remainingText);
            break;
          }

          let chunkEnd = maxLength;
          const lastParagraphBreak = remainingText.lastIndexOf(
            "\n\n",
            maxLength
          );

          if (lastParagraphBreak > maxLength / 2) {
            chunkEnd = lastParagraphBreak;
          }

          chunks.push(remainingText.substring(0, chunkEnd));
          remainingText = remainingText.substring(chunkEnd);
        }

        return chunks;
      }

      async function processChunk(chunk, systemPrompt) {
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const payload = {
          contents: [{ parts: [{ text: chunk }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_NONE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_NONE",
            },
          ],
        };

        let response;
        let retries = 3;
        let delay = 1000;
        for (let i = 0; i < retries; i++) {
          response = await fetch(apiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          if (response.ok) break;
          if (response.status === 429 || response.status >= 500) {
            await new Promise((res) => setTimeout(res, delay));
            delay *= 2;
          } else {
            break;
          }
        }

        if (!response.ok) {
          throw new Error(`Lỗi HTTP! Trạng thái: ${response.status}`);
        }

        const result = await response.json();
        const candidate = result.candidates?.[0];

        if (candidate && candidate.content?.parts?.[0]?.text) {
          return candidate.content.parts[0].text;
        } else {
          console.error("Lỗi xử lý đoạn văn:", result);
          return `\n\n---\n[LỖI: Không thể xử lý đoạn văn trên]\n---\n${chunk}`;
        }
      }

      async function createSceneDescription(originalText) {
        const systemPrompt = `Bạn là một đạo diễn hình ảnh. Đọc đoạn văn bản sau và viết một mô tả hình ảnh ngắn gọn, an toàn, tập trung vào các yếu tố thị giác để một AI có thể vẽ. Không thêm bất kỳ giải thích nào. Chỉ trả về một chuỗi văn bản mô tả.`;
        const userQuery = `Tạo mô tả hình ảnh cho đoạn văn sau:\n\n---\n\n${originalText}`;

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const payload = {
          contents: [{ parts: [{ text: userQuery }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_NONE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_NONE",
            },
          ],
        };

        let lastError = null;
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            const responseText = await response.text();
            if (!responseText) {
              throw new Error("API không trả về mô tả phân cảnh.");
            }

            if (!response.ok) {
              let errorMessage = `Yêu cầu API thất bại: ${response.statusText}`;
              try {
                const errorResult = JSON.parse(responseText);
                errorMessage = `Yêu cầu API thất bại: ${
                  errorResult.error?.message || response.statusText
                }`;
              } catch (e) {
                errorMessage = `Yêu cầu API thất bại: ${responseText}`;
              }
              throw new Error(errorMessage);
            }

            const result = JSON.parse(responseText);
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (text) {
              return text.trim();
            } else {
              throw new Error("API không trả về mô tả phân cảnh.");
            }
          } catch (error) {
            lastError = error;
            console.error(
              `Attempt ${
                attempt + 1
              }/${maxRetries} failed for scene description: ${error.message}`
            );
            if (attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt) * 1000;
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }
        }
        throw new Error(
          `Tạo mô tả phân cảnh thất bại sau ${maxRetries} lần thử: ${lastError.message}`
        );
      }

      async function sanitizeSceneForImagePrompt(
        sceneText,
        characterDescription
      ) {
        const systemPrompt = `You are a creative assistant that transforms a story scene into a safe-for-work, purely visual description for an image generation AI. 
            Your task is to read the scene and the character descriptions, then write a new, single-paragraph description that focuses ONLY on visual elements:
            - Character poses, facial expressions, and clothing.
            - The environment, lighting, and overall mood.
            - You MUST completely AVOID describing or mentioning any violence, blood, injury, weapons, or sensitive content. 
            - Reinterpret actions like "fighting" or "attacking" into more neutral, artistic descriptions like "characters in a dynamic action pose" or "a tense confrontation".
            - Your output must be a concise, safe-for-work paragraph ready to be used as an image prompt. Do not add any extra explanations.`;

        const userQuery = `
                **Character/Setting Info:** ${characterDescription}
                **Original Scene:** ${sceneText}
                
                Rewrite the "Original Scene" into a safe, visual-only prompt:
            `;
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const payload = {
          contents: [{ parts: [{ text: userQuery }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
        };

        try {
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            console.warn("Sanitization prompt failed, using original text.");
            return sceneText;
          }

          const result = await response.json();
          const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

          if (text) {
            console.log("Sanitized Scene Prompt:", text.trim());
            return text.trim();
          } else {
            console.warn(
              "Sanitization prompt returned no text, using original text."
            );
            return sceneText;
          }
        } catch (error) {
          console.error(
            "Error during scene sanitization, using original text:",
            error
          );
          return sceneText;
        }
      }

      async function generateImageForScene(sceneText, characterDescription) {
        const sanitizedSceneText = await sanitizeSceneForImagePrompt(
          sceneText,
          characterDescription
        );

        const prompt = `
                **Continuity Bible (Absolute Truth):** ${characterDescription}

                **Current Scene:** ${sanitizedSceneText}

                **Your Task:** You are an illustrator. Your ONLY job is to create a single visual panel for the "Current Scene". You MUST follow the "Continuity Bible" with absolute, strict precision. Any deviation in character appearance, clothing (style and color), jewelry, age, or setting details from the "Continuity Bible" is a critical failure. Visual consistency is the most important rule.

                **Style Guidelines:** Adhere to the art style defined in the Continuity Bible. The image must be a high-quality, modern Chinese manhua panel. Characters must be Chinese, and the setting must be in China. The final image must be Full HD 1920:1080, 16:9 aspect ratio.
                
                **Crucial Safety Instructions (Negative Prompt):** The image must be a pure visual illustration. DO NOT generate any of the following: dialogue, speech bubbles, text, captions, watermarks, signatures, explicit violence, blood, gore, injuries, weapons, nudity, sexually suggestive content, hateful symbols, or offensive gestures. The image must be completely safe for all audiences (SFW).
            `;
        return await callGeminiImageAPI(prompt);
      }

      async function generateAutomatedDescription(fullStoryText) {
        const systemPrompt = `Bạn là một "Giám sát Liên tục" (Continuity Supervisor) cho một dự án truyện tranh. Nhiệm vụ của bạn là đọc toàn bộ câu chuyện và tạo ra một "Bảng Dữ liệu Liên tục" (Continuity Bible) duy nhất, cực kỳ chi tiết và không thể thay đổi. Bảng dữ liệu này là NGUỒN THÔNG TIN GỐC DUY NHẤT để đảm bảo tính nhất quán tuyệt đối về mặt hình ảnh xuyên suốt câu chuyện. Nó phải bao gồm:
1. **Mô tả chi tiết TẤT CẢ nhân vật**: Với mỗi nhân vật, hãy liệt kê cụ thể và dứt khoát:
    - **Tên:** [Tên nhân vật]
    - **Tuổi tác:** [Tuổi chính xác hoặc khoảng tuổi rất hẹp, ví dụ: "khoảng 25-27 tuổi"]
    - **Giới tính:** [Nam/Nữ]
    - **Khuôn mặt:** [Mô tả chi tiết hình dáng khuôn mặt, mắt, mũi, miệng, có đặc điểm gì đặc biệt không]
    - **Kiểu tóc:** [Kiểu tóc và màu tóc cụ thể]
    - **Vóc dáng:** [Cao, thấp, gầy, cân đối...]
    - **Trang phục CHÍNH:** [Mô tả chi tiết bộ quần áo nhân vật thường mặc nhất, bao gồm kiểu dáng và MÀU SẮC cụ thể]
    - **Chi tiết cơ thể:** [Trang sức, sẹo, hình xăm, nốt ruồi...]
2. **Mô tả chi tiết Bối cảnh & Đạo cụ**:
    - **Địa điểm chính:** [Mô tả chi tiết các địa điểm quan trọng như nhà cửa, phòng ốc, văn phòng. Nêu rõ phong cách kiến trúc, màu sắc chủ đạo, các đồ vật đặc trưng.]
    - **Đạo cụ quan trọng:** [Liệt kê các đồ vật thường xuyên xuất hiện và mô tả chúng.]
3. **Phong cách nghệ thuật (Art Style)**:
    - [Xác định một phong cách nghệ thuật manhua Trung Quốc nhất quán cho toàn bộ truyện. Ví dụ: "Phong cách manhua hiện đại, nét vẽ sắc sảo, màu sắc tươi sáng, tập trung vào biểu cảm nhân vật."]
Bảng dữ liệu này phải cực kỳ chi tiết để một họa sĩ có thể dựa vào đó vẽ mà không có bất kỳ sai sót nào về tính liên tục. Chỉ trả về phần văn bản mô tả này.`;

        const userQuery = `Tạo "Bảng Dữ liệu Liên tục" cho câu chuyện sau:\n\n---\n\n${fullStoryText}`;

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

        const payload = {
          contents: [{ parts: [{ text: userQuery }] }],
          systemInstruction: { parts: [{ text: systemPrompt }] },
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_NONE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_NONE",
            },
          ],
        };

        let lastError = null;
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            const responseText = await response.text();
            if (!responseText) {
              throw new Error("API đã trả về một phản hồi trống.");
            }

            if (!response.ok) {
              let errorMessage = `Yêu cầu API thất bại: ${response.statusText}`;
              try {
                const errorResult = JSON.parse(responseText);
                errorMessage = `Yêu cầu API thất bại: ${
                  errorResult.error?.message || response.statusText
                }`;
              } catch (e) {
                /* ignore */
              }
              throw new Error(errorMessage);
            }

            const result = JSON.parse(responseText);
            const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (!text) {
              const candidate = result.candidates?.[0];
              const finishReason = candidate
                ? candidate.finishReason
                : "Không có phản hồi";
              let errorMessage = `API không hoàn thành. Lý do: ${finishReason}`;
              if (
                finishReason === "SAFETY" ||
                candidate?.safetyRatings?.some((r) => r.blocked)
              ) {
                errorMessage =
                  "Mô tả bị chặn vì lý do an toàn. Vui lòng điều chỉnh lại nội dung truyện.";
              }
              throw new Error(errorMessage);
            }

            return text.trim();
          } catch (error) {
            lastError = error;
            console.error(
              `Attempt ${
                attempt + 1
              }/${maxRetries} failed for description generation: ${
                error.message
              }`
            );
            if (attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt) * 1000;
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }
        }
        throw new Error(
          `Tạo mô tả thất bại sau ${maxRetries} lần thử: ${lastError.message}`
        );
      }

      async function callGeminiImageAPI(prompt) {
        console.log("Generating image with prompt:", prompt);

        const payload = {
          contents: [{ parts: [{ text: prompt }] }],
          generationConfig: { responseModalities: ["TEXT", "IMAGE"] },
          safetySettings: [
            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
            {
              category: "HARM_CATEGORY_SEXUALLY_EXPLICIT",
              threshold: "BLOCK_NONE",
            },
            {
              category: "HARM_CATEGORY_DANGEROUS_CONTENT",
              threshold: "BLOCK_NONE",
            },
          ],
        };

        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;

        let lastError = null;
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(apiUrl, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });

            const responseText = await response.text();
            if (!responseText) {
              throw new Error("API đã trả về một phản hồi trống.");
            }

            const result = JSON.parse(responseText);

            if (!response.ok) {
              console.error("API Error Response:", result);
              throw new Error(
                `Yêu cầu API thất bại: ${
                  result.error?.message || response.statusText
                }`
              );
            }

            const candidate = result.candidates?.[0];

            if (!candidate || candidate.finishReason !== "STOP") {
              const finishReason = candidate
                ? candidate.finishReason
                : "Không có phản hồi";
              let errorMessage = `API không hoàn thành. Lý do: ${finishReason}`;
              if (
                finishReason === "SAFETY" ||
                candidate?.safetyRatings?.some((r) => r.blocked)
              ) {
                errorMessage =
                  "Ảnh bị chặn vì lý do an toàn. Vui lòng điều chỉnh lại nội dung.";
              }
              throw new Error(errorMessage);
            }

            const base64Data = candidate?.content?.parts?.find(
              (p) => p.inlineData
            )?.inlineData?.data;

            if (!base64Data) {
              const textResponse = candidate?.content?.parts?.find(
                (p) => p.text
              )?.text;
              if (textResponse) {
                console.warn(
                  "API trả về văn bản thay vì hình ảnh:",
                  textResponse
                );
                throw new Error(
                  `API đã từ chối tạo ảnh: ${textResponse.substring(0, 100)}...`
                );
              }
              throw new Error(
                "Không có dữ liệu hình ảnh trong phản hồi của API."
              );
            }

            return `data:image/png;base64,${base64Data}`;
          } catch (error) {
            lastError = error;
            console.error(
              `Attempt ${
                attempt + 1
              }/${maxRetries} failed for image generation: ${error.message}`
            );
            if (attempt < maxRetries - 1) {
              const delay = Math.pow(2, attempt) * 1000;
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }
        }
        throw new Error(
          `Tạo ảnh thất bại sau ${maxRetries} lần thử: ${lastError.message}`
        );
      }

      function createSceneCard(
        id,
        sceneText,
        originalText,
        isLoading,
        imageUrl,
        errorMsg = null
      ) {
        const card = document.createElement("div");
        card.id = id;
        card.className = "glass-card p-6 rounded-2xl animate-fade-in";
        card.innerHTML = getCardInnerHtml(
          id,
          sceneText,
          originalText,
          isLoading,
          imageUrl,
          errorMsg
        );
        resultsContainer.appendChild(card);
        lucide.createIcons();
      }

      function updateSceneCard(
        id,
        sceneText,
        originalText,
        isLoading,
        imageUrl,
        errorMsg = null
      ) {
        const card = document.getElementById(id);
        if (card) {
          card.innerHTML = getCardInnerHtml(
            id,
            sceneText,
            originalText,
            isLoading,
            imageUrl,
            errorMsg
          );
          lucide.createIcons();
        } else {
          createSceneCard(
            id,
            sceneText,
            originalText,
            isLoading,
            imageUrl,
            errorMsg
          );
        }
      }

      function getCardInnerHtml(
        id,
        sceneText,
        originalText,
        isLoading,
        imageUrl,
        errorMsg
      ) {
        let imageHtml;
        if (isLoading) {
          imageHtml = `
                    <div class="aspect-video w-full bg-gray-900 rounded-lg flex items-center justify-center">
                        <div class="spinner"></div>
                    </div>`;
        } else if (errorMsg) {
          imageHtml = `
                    <div class="aspect-video w-full bg-red-900/50 rounded-lg flex flex-col items-center justify-center text-center p-4 text-red-400">
                        <i data-lucide="alert-triangle" class="w-12 h-12 mb-2"></i>
                        <p class="font-semibold">Lỗi tạo ảnh</p>
                        <p class="text-sm mb-4">${errorMsg}</p>
                        <button class="regenerate-btn bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg flex items-center gap-2 transition-colors">
                           <i data-lucide="refresh-cw" class="w-4 h-4"></i>
                           Tạo lại
                        </button>
                    </div>`;
        } else {
          const history = imageHistory[id] || [];
          const canRestore = history.length > 1;

          imageHtml = `
                    <div class="relative group aspect-video w-full image-container-for-modal cursor-pointer">
                        <img src="${imageUrl}" alt="Ảnh minh họa cho truyện" class="w-full h-full rounded-lg object-cover">
                        <div class="absolute inset-0 bg-black bg-opacity-0 group-hover:bg-opacity-60 transition-all duration-300 flex items-center justify-center gap-2">
                            <button class="download-btn bg-white/20 hover:bg-white/30 text-white font-semibold p-3 rounded-full flex items-center gap-2 backdrop-blur-sm opacity-0 group-hover:opacity-100 transition-opacity">
                                <i data-lucide="download" class="w-5 h-5"></i>
                            </button>
                            <button class="regenerate-btn bg-white/20 hover:bg-white/30 text-white font-semibold p-3 rounded-full flex items-center gap-2 backdrop-blur-sm opacity-0 group-hover:opacity-100 transition-opacity">
                                <i data-lucide="refresh-cw" class="w-5 h-5"></i>
                            </button>
                            <button class="restore-btn bg-white/20 hover:bg-white/30 text-white font-semibold p-3 rounded-full flex items-center gap-2 backdrop-blur-sm ${
                              canRestore
                                ? "opacity-0 group-hover:opacity-100"
                                : "opacity-0 cursor-not-allowed"
                            }" ${!canRestore ? "disabled" : ""}>
                                <i data-lucide="rotate-ccw" class="w-5 h-5"></i>
                            </button>
                        </div>
                    </div>`;
        }

        return `
                ${imageHtml}
                <div class="mt-4 space-y-4">
                    <div class="bg-gray-900/50 p-4 rounded-lg">
                        <h4 class="text-sm font-semibold text-indigo-300 mb-2 flex items-center">
                            <i data-lucide="image-play" class="w-4 h-4 mr-2"></i>
                            Gợi ý cho phân cảnh
                        </h4>
                        <p class="text-gray-300 italic scene-text-p">"${sceneText}"</p>
                    </div>
                    <div class="bg-gray-900/50 p-4 rounded-lg">
                        <h4 class="text-sm font-semibold text-green-300 mb-2 flex items-center">
                            <i data-lucide="book-open" class="w-4 h-4 mr-2"></i>
                            Khớp với đoạn truyện gốc
                        </h4>
                        <p class="text-gray-400 italic original-text-p">"${originalText}"</p>
                    </div>
                </div>
            `;
      }

      function setLoadingState(isLoading, text = "") {
        if (isLoading) {
          statusContainer.classList.remove("hidden");
          statusContainer.classList.add("flex");
          statusText.textContent = text;
          generateBtn.disabled = true;
          generateBtn.classList.add("opacity-50", "cursor-not-allowed");
        } else {
          statusContainer.classList.add("hidden");
          statusContainer.classList.remove("flex");
          generateBtn.disabled = false;
          generateBtn.classList.remove("opacity-50", "cursor-not-allowed");
        }
      }

      function displayError(message) {
        placeholder.classList.remove("hidden");
        resultsContainer.innerHTML = "";

        const errorHtml = `
                <div class="text-center p-12 glass-card rounded-2xl flex flex-col items-center justify-center h-full text-red-400">
                    <i data-lucide="alert-circle" class="w-24 h-24 mb-4"></i>
                    <h3 class="text-xl font-semibold">${message}</h3>
                </div>`;
        resultsContainer.innerHTML = errorHtml;
        lucide.createIcons();
      }

      function openModal(src) {
        modalImage.src = src;
        imageModal.classList.remove("hidden");
      }

      function closeModal() {
        imageModal.classList.add("hidden");
        modalImage.src = ""; // Clear src to prevent showing old image briefly
      }
    </script>
  </body>
</html>
